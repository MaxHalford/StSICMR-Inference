{"name":"StSICMR-Inference","tagline":"","body":"![StSICMR](http://i.imgur.com/MtvTjvh.png)\r\n\r\n## Symmetrical Island Model with Changes in Migration Rates - Inference\r\n\r\nThe Symmetrical Island Model with Changes in Migration Rates (StSICMR) is a model developped by [Oliver Mazet](http://fr.viadeo.com/fr/profile/olivier.mazet1) and [Lounès Chikhi](https://www.wikiwand.com/en/Loun%C3%A8s_Chikhi) with their research team.\r\n\r\nThis repository supposes that you are familiar with the [PSMC algorithm](http://www.nature.com/nature/journal/v475/n7357/full/nature10231.html) developped by [Richard Durbin](https://www.wikiwand.com/en/Richard_M._Durbin) and [Heng Li](https://www.wikiwand.com/en/Heng_Li).\r\n\r\nThe method tries to fit the model to a PSMC timeline produced with [Heng Li's algorithm](https://github.com/lh3/psmc). It starts by extracting the times and the lambda values of the last iteration from a ``.psmc`` file. Then it normalizes the lambda value so that they start at 1 (because the model is normalized to begin at 1 also). For the fitting part it uses a [genetic algorithm](http://www.wikiwand.com/en/Genetic_algorithm) using [tournament selection](https://www.wikiwand.com/en/Tournament_selection). The implementation is done in Python 3.4 and is designed to be comprehensible and easy to edit. I wrote a [tutorial on genetic algorithms](http://maxhalford.com/resources/notebooks/genetic-algorithms.html) to explain how I code genetic algorithms with Python.\r\n\r\n## Table of Contents\r\n\r\n- [Setup](#setup)\r\n- [Usage](#usage)\r\n- [Examples](#examples)\r\n- [Output](#output)\r\n- [Architecture](#architecture)\r\n- [Contact](#contact)\r\n- [License](#license)\r\n\r\n## Setup\r\n\r\nAll of the code has been tested with both Python 2 and Python 3. People have successfully used it on Ubuntu, Mac OS and Windows. You can either use your current Python installation, a virtual environment or the [Anaconda distribution](https://store.continuum.io/cshop/anaconda/).\r\n\r\n### 1. Normal\r\n\r\nThe following module versions were used, that said older and newer versions have a good chance of working too.\r\n\t\r\n    - matplotlib == 1.4.3\r\n    - pandas == 0.16.2\r\n    - Cython == 0.22.1\r\n    - numpy == 1.9.2\r\n\r\nIf you do not have them installed type\r\n\r\n```sh\r\ncd StSICMR-Inference\r\npip3 install -r requirements.txt\r\n```\r\n\t\r\nIf you don't have ``pip`` installed then you can install the modules manually, this should be easy on any platform as all of them are extremely popular modules.\r\n\r\n### 2. With a virtual environment\r\n\r\nIf you want to be safe and not mess with your Python environment you can create a [virtual environment](http://docs.python-guide.org/en/latest/dev/virtualenvs/) by doing the following steps.\r\n\r\n**1. Clone the repository**\r\n\r\n```sh\r\ngit clone https://github.com/MaxHalford/StSICMR-Inference\r\ncd StSICMR-Inference\r\n```\r\n\t\r\n**2. Create and activate a virtual environment**\r\n\r\n```sh\r\nvirtualenv -p /usr/bin/python3 venv\r\nsource venv/bin/activate\r\n```\r\n\t\r\n**3. Install requirements**\r\n\r\n```sh\r\npip3 install -r requirements.txt\r\n```\r\n\r\nThis creates a sandboxed Python where you can do as you please without fear of screwing up your setup. The only thing required is to have Python 3.x installed in order to run ``virtualenv env``. To deactivate the virtual environment type ``deactivate``. To activate it type ``source venv/bin/activate``, if you don't the default Python interpreter will be used. You can delete the ``StSICMR-Inference`` folder and it will be as if nothing ever happened.\r\n\r\n### 3. Anaconda\r\n\r\nThis is probably the easiest way if you don't have Python installed. Simply [download Anaconda](http://continuum.io/downloads) for your platform (you can choose between Python 2 or 3). Anaconda includes all the modules necessary so there is nothing else to do.\r\n\r\n## Usage\r\n\r\n### Convert\r\n\r\nThe algorithm requires a CSV file. Most of the time these are to be extracted from PSMC files. The ``convert.py``script can do this, as can be seen in the [Examples](#examples) section. You can use any CSV file, the first column will be considered as the time vector and the second one as the PSMC vector.\r\n\r\n### Infer\r\n\r\nThe main script is called ``infer.py`` and guesses the parameters for a given PSMC timeline.\r\n\r\n| Argument | Name        | Description                                                  | Default    |\r\n|----------|-------------|--------------------------------------------------------------|------------|\r\n| -v       | Version     | Get the version of the script.                               |            |\r\n| -n       | Islands     | Maximal number of islands for the first generation.          | 100        |\r\n| -s       | Switches    | Number of switches for the model.                            | 0          |\r\n| -p       | Size        | Initial generation size.                                     | 1000       |\r\n| -r       | Repetitions | Number of times to repeat the process.                       | 1          |\r\n| -g       | Generations | Number of iterations for each population.                    | 100        |\r\n| -u       | Rate        | Rate at which the parameters mutate.                         | 1          |\r\n| -m       | Method      | Method for evaluating the fits.                              | 'integral' |\r\n| -k       | Keep        | Set to True to save the inference as a plot and a JSON file. | 'False'    |\r\n| -o       | Outfile     | Override name of output files.                               |            |\r\n\r\nThe initial number of islands (``-n``) is not important as the algorithm usually finds the right number of islands straight away. The higher the initial population size (``-p``) is the more of the search space will be covered at first. For repeating the process you can use the repetitions arguments (``-r``) and the best model will be saved. The genetic algorithm implementation stops after a fixed number of generations (``g``). The mutation rate (``u``) is important; if it is high the algorithm will not get stuck, at the cost of precision. There are two methods (``m``) for measuring the distance between two curves:\r\n\r\n- the least squares on the vectors which doesn't take into account the abscissa (``'least_squares'``).\r\n- the least squares on the functions which does take into account the abscissa (``'integral'``).\r\n\r\nIf the keep argument (``-k``) is set to ``'True'`` then the best model will be saved as a PNG file for the chart and a JSON file for the parameters with default names. You can also use the outfile argument (``-o``) for overriding the name given to the saved files.\r\n\r\n### Manual\r\n\r\nThe other script called ``manual.py`` is for visualizing a model with user-defined parameters.\r\n\r\n| Argument | Name            |\r\n|----------|-----------------|\r\n| -n       | Islands         |\r\n| -T       | Switch times    |\r\n| -M       | Migration rates |\r\n| -k       | Keep            |\r\n| -o       | Override        |\r\n\r\n### Taming the genetic algorithm\r\n\r\n- Increasing the generation size can have an impact, the longer the algorithm runs the lower the chance that the algorithm won't improve the model.\r\n- If the algorithm seems to fail you can try to increase the mutation rate. Often is the case this will enable it to find a better area. However a high mutation rate removes precision from the algorithm.\r\n- *Trying again* isn't a bad idea when using genetic algorithms.\r\n- The initial population size can be important, the higher it is and the more of the search space will be explored at first.\r\nThe genetic algorithm uses [tournament selection](https://www.wikiwand.com/en/Tournament_selection) for choosing which individuals will breed new individuals. You can configure the parameters of the tournament in the ``lib/inference/tournamentOptions.json`` file:\r\n\t- ``\"rounds\"`` is the number of individuals that will breed new individuals.\r\n\t- ``\"roundSize\"`` is the size of each tournament.\r\n\t- ``\"offspring\"`` is the quantity of individuals the chosen individuals will breed.\r\n\tThere are offspring x rounds number of new individuals. The way the tournament works is that the best out of a random \t\tsample of individuals is chosen. This means that big tournaments are favorable to strong individuals and small \t\t\ttournaments allow weaker individuals to go through (which isn't necessarily a bad thing, \t\t\t\t\t[simulated annealing](http://www.wikiwand.com/en/Simulated_annealing) does the same thing).\r\n\r\n## Examples\r\n\r\nExamples are available in the GitHub repository's README.md.\r\n\r\n## Output\r\n\r\nChanging the chart outputs is really easy. The ``lib/chartOptions.json``file is made for easily doing so. The default settings produce the charts you see in the [Examples](#examples) section. Most of the parameters are not too hard to understand. I would recommend reading the documentation from [matplotlib](http://matplotlib.org/contents.html) if you want to do something complicated.\r\n\r\n## Architecture\r\n\r\n    StSICMR-Inference\r\n    ├───┐ examples\r\n    │   ├─── example1.csv\r\n    │   ├─── example1.psmc\r\n    │   ├─── example1_0_switch.json\r\n    │   ├─── example1_0_switch.png\r\n    │   ├─── example2.csv\r\n    │   ├─── example2.psmc\r\n    │   ├─── example2_3_switch.json\r\n    │   ├─── example2_3_switch.png\r\n    │   ├─── example3.csv\r\n    │   ├─── example3.psmc\r\n    │   ├─── example3_manual.json\r\n    │   └─── example3_manual.png\r\n    ├───┐ lib\r\n    │   ├───┐ cython\r\n    │   │   ├─── compile.sh\r\n    │   │   ├─── cythonized.c\r\n    │   │   ├─── cythonized.pyx\r\n    │   │   └─── setup.py\r\n    │   ├───┐ inference\r\n    │   │   ├─── __init.py__\r\n    │   │   ├─── distance.py\r\n    │   │   ├─── genalg.py\r\n    │   │   └─── tournamentOptions.json\r\n    │   ├─── __init__.py\r\n    │   ├─── chartOptions.json\r\n    │   ├─── model.py\r\n    │   ├─── plotting.py\r\n    │   └─── tools.py\r\n    ├─── convert.py\r\n    ├─── infer.py\r\n    ├─── LICENSE\r\n    ├─── manual.py\r\n    ├─── README.md\r\n    └─── requirements.txt\r\n\r\nThe two main scripts (``infer.py`` and ``manual.py``) are in the top-level of the directory. In the ``lib`` folder is where the heavy-lifting is being done:\r\n\r\n- ``model.py`` contains the StSCMIR class where the mathematics are done. \r\n- ``tools.py`` is for opening and parsing a ``.psmc`` file.\r\n- ``genalg.py`` tries to find good parameters for the model to fit a PSMC timeline.\r\n- ``plotting.py`` plots a model and a PSMC timeline on the same chart.\r\n\r\nThe reason why ``lib`` contains the ``ìnference`` folder is if ever there will be another method of infering the parameters, it doesn't necessarily have to be a genetic algorithm. However the distance measures between the target curve and the model curve will always be the same, hence the ``distance.py`` script that can easily be reused with other methods.\r\n\r\nOne of the flaws of genetic algorithms is their computational cost. The ``cython`` folder aims at speeding up some of the mathematics done in the ``model.py`` script (for example eigenvalues and diagonalization). For the moment I haven't done much work here (I want to learn how to do good C code) but I will be in the future. If ever you want to add some C code you can use [cprofilev](https://github.com/ymichael/cprofilev) to check what functions are taking the most time. Once you have added code to ``cythonized.pyx`` you can compile it to C code with ``compile.sh`` script, it's as easy as that.\r\n\r\n## Contact\r\n\r\nIf you have questions about the mathematics please send a mail to <willyrv@gmail.com>.\r\n\r\nIf you have questions about the genetic algorithm and/or the code please send a mail to <maxhalford25@gmail.com>.\r\n\r\n## License\r\n\r\nSee the [LICENSE file](LICENSE).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}